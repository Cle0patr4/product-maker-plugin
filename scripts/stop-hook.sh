#!/bin/bash
# Product Maker Stop Hook
# This hook intercepts Claude's exit attempts and continues the loop until completion

set -euo pipefail

STATE_FILE=".product-maker-state.yaml"
LOG_FILE=".product-maker/loop.log"

# Create log directory if it doesn't exist
mkdir -p "$(dirname "$LOG_FILE")"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

# Check if state file exists
if [[ ! -f "$STATE_FILE" ]]; then
    log "No active product-maker loop found. Exiting normally."
    exit 0  # Allow normal exit
fi

# Read state file
if ! STATE=$(cat "$STATE_FILE" 2>/dev/null); then
    log "Error reading state file. Exiting normally."
    exit 0
fi

# Parse YAML using grep and sed (simple parsing, no dependencies)
get_value() {
    local key=$1
    grep "^$key:" "$STATE_FILE" | sed "s/^$key: *//" | sed 's/^"//' | sed 's/"$//'
}

ACTIVE=$(get_value "active")
CURRENT_ITERATION=$(get_value "current_iteration")
MAX_ITERATIONS=$(get_value "max_iterations")
COMPLETION_PROMISE=$(get_value "completion_promise")
REFLECTION_ENABLED=$(get_value "reflection_enabled")
CHECKPOINT_INTERVAL=$(get_value "checkpoint_interval")

# Extract prompt (everything after the second ---)
PROMPT=$(awk '/^---$/{n++; next} n==2{print}' "$STATE_FILE")

# Check if loop is active
if [[ "$ACTIVE" != "true" ]]; then
    log "Loop is not active. Exiting normally."
    exit 0
fi

# Increment iteration counter
CURRENT_ITERATION=$((CURRENT_ITERATION + 1))
log "Starting iteration $CURRENT_ITERATION of $MAX_ITERATIONS"

# Check if max iterations reached
if [[ $CURRENT_ITERATION -gt $MAX_ITERATIONS ]]; then
    log "Max iterations ($MAX_ITERATIONS) reached. Stopping loop."
    log "Product building incomplete. Consider:"
    log "  1. Increasing max iterations"
    log "  2. Breaking down into smaller phases"
    log "  3. Refining your prompt for better convergence"
    
    # Deactivate loop
    sed -i "s/active: true/active: false/" "$STATE_FILE"
    exit 0  # Allow exit
fi

# Check for completion promise in recent output
# Look in the last Claude response (this is a simplified check)
if [[ -n "$COMPLETION_PROMISE" ]]; then
    # Check git log for the completion promise
    if git log -1 --pretty=%B 2>/dev/null | grep -q "$COMPLETION_PROMISE"; then
        log "Completion promise found: '$COMPLETION_PROMISE'"
        log "Product building complete! ðŸŽ‰"
        
        # Deactivate loop
        sed -i "s/active: true/active: false/" "$STATE_FILE"
        
        # Create completion report
        REFLECTION_INFO=""
        if [[ "$REFLECTION_ENABLED" == "true" ]]; then
            REFLECTION_INFO="
## Reflection Mode

- **Reflection**: Enabled
- **Checkpoint Interval**: $CHECKPOINT_INTERVAL iterations
- **Total Checkpoints**: $((CURRENT_ITERATION / CHECKPOINT_INTERVAL))
- **Last Checkpoint**: $(get_value 'last_checkpoint_at')

See ITERATION-LOG.md and CHECKPOINT-REPORT.md for detailed progress history.
"
        fi

        cat > ".product-maker/completion-report.md" <<EOF
# Product Maker - Completion Report

**Completion Time**: $(date)
**Total Iterations**: $CURRENT_ITERATION
**Status**: SUCCESS âœ…
$REFLECTION_INFO
## Completion Criteria Met

- Completion promise detected: \`$COMPLETION_PROMISE\`

## Final State

$(git log -1 --pretty=fuller)

## Next Steps

1. Review the built product
2. Run manual tests
3. Deploy to production if not already done
4. Archive this completion report

## Prompt Used

\`\`\`
$PROMPT
\`\`\`

---
Generated by Product Maker Plugin
EOF
        
        log "Completion report created: .product-maker/completion-report.md"
        exit 0  # Allow exit
    fi
fi

# Determine if this is a checkpoint iteration
IS_CHECKPOINT=0
if [[ "$REFLECTION_ENABLED" == "true" ]] && [[ $CHECKPOINT_INTERVAL -gt 0 ]]; then
    if [[ $((CURRENT_ITERATION % CHECKPOINT_INTERVAL)) -eq 0 ]]; then
        IS_CHECKPOINT=1
    fi
fi

# Calculate next checkpoint iteration
NEXT_CHECKPOINT=$((CURRENT_ITERATION + CHECKPOINT_INTERVAL - (CURRENT_ITERATION % CHECKPOINT_INTERVAL)))
if [[ $NEXT_CHECKPOINT -gt $MAX_ITERATIONS ]]; then
    NEXT_CHECKPOINT=$MAX_ITERATIONS
fi

# Build the enhanced prompt based on reflection mode
ENHANCED_PROMPT="$PROMPT"

if [[ "$REFLECTION_ENABLED" == "true" ]]; then
    if [[ "$IS_CHECKPOINT" -eq 1 ]]; then
        # CHECKPOINT ITERATION - Full validation
        log "CHECKPOINT iteration $CURRENT_ITERATION - triggering full validation"

        ENHANCED_PROMPT="$PROMPT

âš ï¸ CHECKPOINT ITERATION $CURRENT_ITERATION âš ï¸

IGNORE ITERATION-LOG.md for this iteration. Perform FULL VALIDATION:

1. Run ALL tests and report results
2. Review ALL code files for:
   - Security vulnerabilities
   - Performance issues
   - Code quality problems
   - Incomplete implementations
3. Check ALL integrations are working
4. Verify ALL features from original prompt

Create/Update CHECKPOINT-REPORT.md with:
- Full test results
- All issues found
- Code quality assessment
- Integration status
- Top 3 priorities for next $CHECKPOINT_INTERVAL iterations

Then continue with normal development.
"
    else
        # NORMAL ITERATION - Use reflection log
        log "Reflection iteration $CURRENT_ITERATION (next checkpoint: $NEXT_CHECKPOINT)"

        ENHANCED_PROMPT="$PROMPT

ðŸ“ ITERATION $CURRENT_ITERATION (Next checkpoint: iteration $NEXT_CHECKPOINT)

FIRST, read ITERATION-LOG.md to see:
- What was done in previous iterations
- Current test status
- Known blockers
- Next planned task

THEN:
1. Continue with the next logical task
2. Run tests related to your changes
3. Update ITERATION-LOG.md with:
   - Files you modified THIS iteration
   - Test results (passing/failing counts)
   - Any new blockers or issues
   - Next immediate task (1 sentence)

IMPORTANT:
- The log is a GUIDE, not a replacement for testing
- Always run tests to verify your changes
- Read full files when debugging
- Don't trust the log blindly - verify assumptions
"
    fi
fi

# Update state file with new iteration count and checkpoint tracking
LAST_CHECKPOINT_AT=$(get_value 'last_checkpoint_at')
if [[ "$IS_CHECKPOINT" -eq 1 ]]; then
    LAST_CHECKPOINT_AT="$(date -Iseconds)"
fi

cat > "$STATE_FILE" <<EOF
---
active: true
current_iteration: $CURRENT_ITERATION
max_iterations: $MAX_ITERATIONS
completion_promise: "$COMPLETION_PROMISE"
reflection_enabled: $REFLECTION_ENABLED
checkpoint_interval: $CHECKPOINT_INTERVAL
started_at: "$(get_value 'started_at')"
last_iteration_at: "$(date -Iseconds)"
last_checkpoint_at: "$LAST_CHECKPOINT_AT"
---
$PROMPT
EOF

log "Continuing loop. Progress: $CURRENT_ITERATION/$MAX_ITERATIONS"

# Block exit and feed enhanced prompt back to Claude
# Exit code 2 tells Claude Code to continue with the prompt from the state file
echo "$ENHANCED_PROMPT"
exit 2
